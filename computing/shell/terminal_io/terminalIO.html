<!-- Not by Vern Hoxie.  Author unknown-->
<!-- X-URL: http://www2.ecst.csuchico.edu/~bapper/298c/notes/notes7.html -->
<!-- Date: Wed, 08 Dec 1999 07:20:27 GMT -->
<script src="//archive.org/includes/analytics.js?v=cf34f82" type="text/javascript"></script>
<script type="text/javascript">window.addEventListener('DOMContentLoaded',function(){var v=archive_analytics.values;v.service='wb';v.server_name='wwwb-app214.us.archive.org';v.server_ms=647;archive_analytics.send_pageview({});});</script>
<script type="text/javascript" src="/_static/js/bundle-playback.js?v=rQCmsv02" charset="utf-8"></script>
<script type="text/javascript" src="/_static/js/wombat.js?v=UHAOicsW" charset="utf-8"></script>
<script type="text/javascript">
  __wm.init("https://web.archive.org/web");
  __wm.wombat("http://www.lafn.org:80/~dave/linux/terminalIO.html","20161224020948","https://web.archive.org/","web","/_static/",
	      "1482545388");
</script>
<link rel="stylesheet" type="text/css" href="/_static/css/banner-styles.css?v=fantwOh2" />
<link rel="stylesheet" type="text/css" href="/_static/css/iconochive.css?v=qtvMKcIJ" />
<!-- End Wayback Rewrite JS Include -->
<base href="https://web.archive.org/web/20161224020948/http://www2.ecst.csuchico.edu/~bapper/298c/notes/notes7.html">

<!-- BEGIN WAYBACK TOOLBAR INSERT -->
<style type="text/css">
body {
  margin-top:0 !important;
  padding-top:0 !important;
  /*min-width:800px !important;*/
}
</style>
<script>__wm.rw(0);</script>
<div id="wm-ipp-base" lang="en" style="display:none;direction:ltr;">
<div id="wm-ipp" style="position:fixed;left:0;top:0;right:0;">
<div id="donato" style="position:relative;width:100%;">
  <div id="donato-base">
    <iframe id="donato-if" src="https://archive.org/includes/donate.php?as_page=1&amp;platform=wb&amp;referer=https%3A//web.archive.org/web/20161224020948/http%3A//www.lafn.org%3A80/~dave/linux/terminalIO.html"
	    scrolling="no" frameborder="0" style="width:100%; height:100%">
    </iframe>
  </div>
</div><div id="wm-ipp-inside">
  <div id="wm-toolbar" style="position:relative;display:flex;flex-flow:row nowrap;justify-content:space-between;">
    <div id="wm-logo" style="/*width:110px;*/padding-top:12px;">
      <a href="/web/" title="Wayback Machine home page"><img src="/_static/images/toolbar/wayback-toolbar-logo-200.png" srcset="/_static/images/toolbar/wayback-toolbar-logo-100.png, /_static/images/toolbar/wayback-toolbar-logo-150.png 1.5x, /_static/images/toolbar/wayback-toolbar-logo-200.png 2x" alt="Wayback Machine" style="width:100px" border="0" /></a>
    </div>
    <div class="c" style="display:flex;flex-flow:column nowrap;justify-content:space-between;flex:1;">
      <form class="u" style="display:flex;flex-direction:row;flex-wrap:nowrap;" target="_top" method="get" action="/web/submit" name="wmtb" id="wmtb"><input type="text" name="url" id="wmtbURL" value="http://www.lafn.org/~dave/linux/terminalIO.html" onfocus="this.focus();this.select();" style="flex:1;"/><input type="hidden" name="type" value="replay" /><input type="hidden" name="date" value="20161224020948" /><input type="submit" value="Go" />
      </form>
      <div style="display:flex;flex-flow:row nowrap;align-items:flex-end;">
		<div class="s" id="wm-nav-captures">
	  	  <a class="t" href="/web/20161224020948*/http://www.lafn.org/~dave/linux/terminalIO.html" title="See a list of every capture for this URL">76 captures</a>
	  <div class="r" title="Timespan for captures of this URL">14 Apr 2006 - 22 Mar 2021</div>
	  </div>
	<div class="k" style="flex:1;">
	  <a href="" id="wm-graph-anchor">
	    <div id="wm-ipp-sparkline" title="Explore captures for this URL" style="position: relative">
	      <canvas id="wm-sparkline-canvas" width="675" height="27" border="0"></canvas>
	    </div>
	  </a>
	</div>
      </div>
    </div>
    <div class="n">
      <table>
	<tbody>
	  <!-- NEXT/PREV MONTH NAV AND MONTH INDICATOR -->
	  <tr class="m">
	    <td class="b" nowrap="nowrap"><a href="https://web.archive.org/web/20161105130323/http://www.lafn.org:80/~dave/linux/terminalIO.html" title="05 Nov 2016"><strong>Nov</strong></a></td>
	    <td class="c" id="displayMonthEl" title="You are here: 02:09:48 Dec 24, 2016">DEC</td>
	    <td class="f" nowrap="nowrap"><a href="https://web.archive.org/web/20170910160148/http://www.lafn.org:80/~dave/linux/terminalIO.html" title="10 Sep 2017"><strong>Sep</strong></a></td>
	  </tr>
	  <!-- NEXT/PREV CAPTURE NAV AND DAY OF MONTH INDICATOR -->
	  <tr class="d">
	    <td class="b" nowrap="nowrap"><a href="https://web.archive.org/web/20161105130323/http://www.lafn.org:80/~dave/linux/terminalIO.html" title="13:03:23 Nov 05, 2016"><img src="/_static/images/toolbar/wm_tb_prv_on.png" alt="Previous capture" width="14" height="16" border="0" /></a></td>
	    <td class="c" id="displayDayEl" style="width:34px;font-size:22px;white-space:nowrap;" title="You are here: 02:09:48 Dec 24, 2016">24</td>
	    <td class="f" nowrap="nowrap"><a href="https://web.archive.org/web/20170910160148/http://www.lafn.org:80/~dave/linux/terminalIO.html" title="16:01:48 Sep 10, 2017"><img src="/_static/images/toolbar/wm_tb_nxt_on.png" alt="Next capture" width="14" height="16" border="0" /></a></td>
	  </tr>
	  <!-- NEXT/PREV YEAR NAV AND YEAR INDICATOR -->
	  <tr class="y">
	    <td class="b" nowrap="nowrap"><a href="https://web.archive.org/web/20151008041759/http://www.lafn.org:80/~dave/linux/terminalIO.html" title="08 Oct 2015"><strong>2015</strong></a></td>
	    <td class="c" id="displayYearEl" title="You are here: 02:09:48 Dec 24, 2016">2016</td>
	    <td class="f" nowrap="nowrap"><a href="https://web.archive.org/web/20180129095147/http://www.lafn.org/~dave/linux/terminalIO.html" title="29 Jan 2018"><strong>2018</strong></a></td>
	  </tr>
	</tbody>
      </table>
    </div>
    <div class="r" style="display:flex;flex-flow:column nowrap;align-items:flex-end;justify-content:space-between;">
      <div id="wm-btns" style="text-align:right;height:23px;">
        	<span class="xxs">
          <div id="wm-save-snapshot-success">success</div>
          <div id="wm-save-snapshot-fail">fail</div>
          <a id="wm-save-snapshot-open" href="#"
	     title="Share via My Web Archive" >
            <span class="iconochive-web"></span>
          </a>
          <a href="https://archive.org/account/login.php" title="Sign In" id="wm-sign-in">
            <span class="iconochive-person"></span>
          </a>
          <span id="wm-save-snapshot-in-progress" class="iconochive-web"></span>
	</span>
        	<a class="xxs" href="http://faq.web.archive.org/" title="Get some help using the Wayback Machine" style="top:-6px;"><span class="iconochive-question" style="color:rgb(87,186,244);font-size:160%;"></span></a>
	<a id="wm-tb-close" href="#close" style="top:-2px;" title="Close the toolbar"><span class="iconochive-remove-circle" style="color:#888888;font-size:240%;"></span></a>
      </div>
      <div id="wm-share" class="xxs">
        <a href="/web/20161224020948/http://web.archive.org/screenshot/http://www.lafn.org/~dave/linux/terminalIO.html"
           id="wm-screenshot"
           title="screenshot">
          <span class="wm-icon-screen-shot"></span>
        </a>
        <a href="#" id="wm-video" title="video">
          <span class="iconochive-movies"></span>
        </a>
	<a id="wm-share-facebook" href="#" data-url="https://web.archive.org/web/20161224020948/http://www.lafn.org:80/~dave/linux/terminalIO.html" title="Share on Facebook" style="margin-right:5px;" target="_blank"><span class="iconochive-facebook" style="color:#3b5998;font-size:160%;"></span></a>
	<a id="wm-share-twitter" href="#" data-url="https://web.archive.org/web/20161224020948/http://www.lafn.org:80/~dave/linux/terminalIO.html" title="Share on Twitter" style="margin-right:5px;" target="_blank"><span class="iconochive-twitter" style="color:#1dcaff;font-size:160%;"></span></a>
      </div>
      <div style="padding-right:2px;text-align:right;white-space:nowrap;">
	<a id="wm-expand" class="wm-btn wm-closed" href="#expand" onclick="__wm.ex(event);return false;"><span id="wm-expand-icon" class="iconochive-down-solid"></span> <span class="xxs" style="font-size:80%;">About this capture</span></a>
      </div>
    </div>
  </div>
    <div id="wm-capinfo" style="border-top:1px solid #777;display:none; overflow: hidden">
                    <div id="wm-capinfo-collected-by">
    <div style="background-color:#666;color:#fff;font-weight:bold;text-align:center">COLLECTED BY</div>
    <div style="padding:3px;position:relative" id="wm-collected-by-content">
            <div style="display:inline-block;vertical-align:top;width:50%;">
			<span class="c-logo" style="background-image:url(https://archive.org/services/img/alexacrawls);"></span>
		Organization: <a style="color:#33f;" href="https://archive.org/details/alexacrawls" target="_new"><span class="wm-title">Alexa Crawls</span></a>
		<div style="max-height:75px;overflow:hidden;position:relative;">
	  <div style="position:absolute;top:0;left:0;width:100%;height:75px;background:linear-gradient(to bottom,rgba(255,255,255,0) 0%,rgba(255,255,255,0) 90%,rgba(255,255,255,255) 100%);"></div>
	  Starting in 1996, <a href="http://www.alexa.com/">Alexa Internet</a> has been donating their crawl data to the Internet Archive.  Flowing in every day, these data are added to the <a href="http://web.archive.org/">Wayback Machine</a> after an embargo period.
	</div>
	      </div>
      <div style="display:inline-block;vertical-align:top;width:49%;">
			<span class="c-logo" style="background-image:url(https://archive.org/services/img/alexacrawls)"></span>
		<div>Collection: <a style="color:#33f;" href="https://archive.org/details/alexacrawls" target="_new"><span class="wm-title">Alexa Crawls</span></a></div>
		<div style="max-height:75px;overflow:hidden;position:relative;">
	  <div style="position:absolute;top:0;left:0;width:100%;height:75px;background:linear-gradient(to bottom,rgba(255,255,255,0) 0%,rgba(255,255,255,0) 90%,rgba(255,255,255,255) 100%);"></div>
	  Starting in 1996, <a href="http://www.alexa.com/">Alexa Internet</a> has been donating their crawl data to the Internet Archive.  Flowing in every day, these data are added to the <a href="http://web.archive.org/">Wayback Machine</a> after an embargo period.
	</div>
	      </div>
    </div>
    </div>
    <div id="wm-capinfo-timestamps">
    <div style="background-color:#666;color:#fff;font-weight:bold;text-align:center" title="Timestamps for the elements of this page">TIMESTAMPS</div>
    <div>
      <div id="wm-capresources" style="margin:0 5px 5px 5px;max-height:250px;overflow-y:scroll !important"></div>
      <div id="wm-capresources-loading" style="text-align:left;margin:0 20px 5px 5px;display:none"><img src="/_static/images/loading.gif" alt="loading" /></div>
    </div>
    </div>
  </div></div></div></div><div id="wm-ipp-print">The Wayback Machine - https://web.archive.org/web/20161224020948/http://www.lafn.org:80/~dave/linux/terminalIO.html</div>
<script type="text/javascript">
__wm.bt(675,27,25,2,"web","http://www.lafn.org/~dave/linux/terminalIO.html","20161224020948",1996,"/_static/",["/_static/css/banner-styles.css?v=fantwOh2","/_static/css/iconochive.css?v=qtvMKcIJ"], false);
  __wm.rw(1);
</script>
<!-- END WAYBACK TOOLBAR INSERT --><html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>
    Notes 7: Terminal I/O
</title>
</head>

<body bgcolor="White">

<center><h1>
    Notes 7:<br>
    Terminal I/O<br>
</center></h1>

<h2>Overview:</h2>
<p>

Why should we need to know about terminal I/O with all these nifty
graphical user interfaces out there?  Terminals are thing of the past,
right?  Sorry, in Unix, the terminal device driver controls a lot more
than just terminals.  modems, printers, direct connections to other
computers, and other special devices that rely on streams of
characters.<p>

Terminal devices can be put into different states.  The default state
of the terminal when running in a shell is canonical mode, also known
as cooked mode.  In this mode, the terminal driver returns one line of
data at a time from the terminal device.  Any special characters are
processed as they come into the device (<tt>^C</tt>, <tt>^Z</tt>,
etc.).<p>

The second state the terminal can be in is noncanonical mode, or raw
mode.  In this state, the terminal device driver returns one character
at a time without assembling lines of data.  Also, special characters
are not processed in this mode.  Programs such as vi, pine, and elm
use this mode for data input and output.  This allows complete control
of input and output characters.<p>

A third state, one which Posix.1 defines, is the cbreak mode.  This
mode is similar to raw mode, except that the processing of special
characters still takes place and the corresponding signals are raised
for the special characters.<p>

<h3>P.326 Figure Here</h3><p>

Things to remember about the Input and Output Queues:<p>
<ul>
<li>There is a link between the input and output queue if echoing is
enabled.  This means you don't need to send your keystrokes to stdout
if echoing is enabled, it is done for you.

<li>There is a limit to the size of the input queue, this limit is
defined by the macro <tt>MAX_INPUT</tt>.  This means that if you try
to type a line that is larger than <tt>MAX_INPUT</tt>, then the
terminal device will not read anything beyond the <tt>MAX_INPUT</tt>
number of characters.  Most Unix systems will echo the bell character
(<tt>^G</tt>) when you try to type beyond this limit and the
characters you type will not be echo'd or stored in the queue.

<li>The limit <tt>MAX_CANON</tt> is the maximum number of bytes that can be
stored in an input line.  This is the same as <tt>MAX_INPUT</tt> on many
systems, including Linux and HPUX.

<li>There is an output queue, but you never really need to worry about
this.  If a process tries to write info to the output queue and the
queue is filled up, the kernel will put that process to sleep (it will
block), until there is more room on the queue.  This limit is not
defined in any standard header file.

<li>Most of the processing of the input queue on Unix systems takes
place in a module called the <i>terminal line discipline</i>.  This
takes place between the system functions and the device driver.
</ul>

<h3>P. 327 Figure Here</h3>

<p>
<h2>Getting and Setting the Terminal Attributes:</h2><p>

All of the attributes that can be controlled in the terminal device
are contained in the <tt>termios</tt> structure.  This structure is
defined as:

<tt><pre>
    struct termios {
        tcflag_t    c_iflag;    /* input flags */
        tcflag_t    c_oflag;    /* output flags */
        tcflag_t    c_cflag;    /* control flags */
        tcflag_t    c_lflag;    /* local flags */
        cc_t        c_cc[NCCS]; /* control characters */
    };
</pre></tt>

The <tt>c_iglag</tt> attribute is what controls any input
characteristics of the terminal (map CR to NL, ring bell on input
queue full, etc.).  The <tt>c_oflag</tt> attribute is what you set to
control any output processing of the terminal (expand tabs to spaces,
map lowercase to uppercase on output, etc.).  Most of the
<tt>c_oflag</tt> settings are not Posix compliant.  The
<tt>c_cflag</tt> attribute is for setting the serial line attributes
(enable parity, set flow control, etc.).  The <tt>c_lflag</tt>
attribute is for the settigns of the interface between the user and
the device driver (local echo, enable signals generated byt the
terminal, etc.).<p>

This structure is used with two different functions,
<tt>tcgetattr()</tt> and <tt>tcsetattr()</tt>.  The prototypes are as
follows: <br>

<p>
<center>
<table border="2">
<tr>
<td>
<tt><pre>
    #include &lt;termios.h&gt;

    int tcgetattr(int <i>filedes</i>, struct termios *<i>termptr</i>);

    int tcsetattr(int <i>filedes</i>, int <i>opt</i>, const struct termios *<i>termptr</i>);
    </pre></tt>
    <p align="right">Both return: 0 if OK, -1 on error</p>
</td> </tr>
</table>
</center>

<p>As the names suggest, <tt>tcgetattr()</tt> gets the current state
of the terminal that the open file descriptor <tt><i>filedes</i></tt>
points to, and <tt>tcsetattr()</tt> sets attributes for the terminal
that <tt><i>filedes</i></tt> is associated with.  These functions will
return an error if the <tt><i>filedes</i></tt> argument is not
associated with a terminal device.

<p>The argument <tt><i>opt</i></tt> in <tt>tcsetattr()</tt> is for
specifying when the changes are to take place.  This is defined by the
following macros:<br>

<p>
<dl>
<dt>
<dd>
<table border="0" cellpadding="5">
<tr valign="top">
  <td><tt>TCSANOW</tt></td>
  <td>Make the changes now.</td>
</tr>
<tr valign="top">
  <td><tt>TCSADRAIN</tt></td>
  <td>Make the changes after all output has been transmitted from the
      buffer.  This should be used when setting output attributes.</td>
</tr>
<tr valign="top">
  <td><tt>TCSAFLUSH</tt></td>
  <td>Make the changes after all output has been transmitted, and
      flush the input queue of any unprocessed data.</td>
</tr>
</table>
</dd>
</dt>
</dl>

<p>
<h2>How fast are we talking?</h2><p>
Sometimes you may find that you need to change the speed of the terminal
dsession to match that of the device it is connected to.  This is done
with four functions in combination with the <tt>tcgetattr()</tt> and
<tt>tcsetattr()</tt> functions.

<p>
<center>
<table border="2">
<tr>
<td>
<tt><pre>
    #include &lt;termios.h&gt;

    speed_t cfgetispeed(const struct termios *<i>termptr</i>);

    speed_t cfgetospeed(const struct termios *<i>termptr</i>); </pre></tt>
    <p align="right">Both return: baud rate value</p>

    <tt><pre>
    speed_t cfsetispeed(struct termios *<i>termptr</i>, speed_t <i>speed</i>);

    speed_t cfsetospeed(struct termios *<i>termptr</i>, speed_t <i>speed</i>); </pre></tt>
    <p align="right">Both return: 0 if OK, -1 on error</p>
</td>
</tr>
</table>
</center>

<p>
The first thing that must be done here in order to change the baud rate
of the terminal is use <tt>tcgetattr()</tt> so that you can pass the termios
struct to the cfset functions.  You then pass the struct to the cfset functions
to set the correct baud rate in the termios struct.  This does not actually
set the terminal speed, however.  You still need to make a call to
<tt>tcsetattr()</tt> with termios struct that has the changed baud rate.<br><p>

<p>
<ol><b>The order of calls to change the baud rate:</b>
<li>tcgetattr()     --  Get the current settings
<li>cfsetispeed()   --  Set the input speed in the termios struct
<li>cfsetospeed()   --  Set the output speed in the termios struct
<li>cfsetattr()     --  Make the changes to the terminal to reflect the
changed struct
</ol>


<p>
<h2>Terminal line control</h2><p>
The line control for the terminal is important if you want to prevent
overflowing the buffer for the device when there is no hardware flow control
implemented.  Also, you can flush the input and/or output of a device
discarding any data that has not already been sent or read from the buffer.<p>

<p>
<center>
<table border="2">
<tr>
<td>
<tt><pre>
    #include &lt;termios.h&gt;

    int tcdrain(int <i>filedes</i>);                                 

    int tcflow(int <i>filedes</i>, int <i>action</i>);

    int tcflush(int <i>filedes</i>, int <i>queue</i>);

    int tcsendbreak(int <i>filedes</i>, int <i>duration</i>);   </pre></tt>
    <p align="right">All four return: 0 if OK, -1 on error</p>
</td>
</tr>
</table>
</center>

<p>
The <tt>tcdrain()</tt> function suspends the process until all of the data in
the ouput buffer has been transmitted.  The <tt>tcflow()</tt> function gives
control over input and output flow control.  The <tt><i>action</i></tt>
argument to <tt>tcflow()</tt> can be any of the following macros:

<p>
<dl>
<dt>
<dd>
<table border="0" cellpadding="5">
<tr valign="top">
  <td><tt>TCOOFF</tt></td>
  <td>Suspend Output</td>
</tr>
<tr valign="top">
  <td><tt>TCOON</tt></td>
  <td>Restart output</td>
</tr>
<tr valign="top">
  <td><tt>TCIOFF</tt></td>
  <td>Suspend input</td>
</tr>
<tr valign="top">
  <td><tt>TCION</tt></td>
  <td>Restart input</td>
</tr>
</table>
</dd>
</dt>
</dl>

<p>
The <tt>tcflush()</tt> function lets us discard input or output buffer data.
Data in the input buffer is data that has been received but not read yet.
Data in the output buffer is data that has been written but not transmitted
yet.  The <tt><i>queue</i></tt> argument can have the follow macro values:

<p>
<dl>
<dt>
<dd>
<table border="0" cellpadding="5">
<tr valign="top">
  <td><tt>TCIFLUSH</tt></td>
  <td>Flush the input buffer</td>
</tr>
<tr valign="top">
  <td><tt>TCOFLUSH</tt></td>
  <td>Flush the output buffer</td>
</tr>
<tr valign="top">
  <td><tt>TCIOFLUSH</tt></td>
  <td>Flush both the input and output buffers</td>
</tr>
</table>
</dd>
</dt>
</dl>

<p>
The <tt>tcsendbreak()</tt> function transmits a continous stream of zero bits.
If the <tt><i>duration</i></tt> attribute is set to <tt>0</tt>, then the
duration of the transmition is between 0.25 and 0.5 seconds.  If the
<tt><i>duration</i></tt> is nonzero, it is implementation specific.  Under
Linux, if the <tt><i>duration</i></tt> is nonzero, the length of transmission
is <b><tt><i>duration</i>*N</tt></b> seconds where N is between 0.25 and 0.5.

<p>
<h2>What Terminal Is This?</h2><p>
At some point in your career, you may want to find out what terminal device
your process is attached to.  In the old days, you could just open
"/dev/tty" and that was the correct terminal for your process all of the
time.  Now, their is a POSIX.1 call that you can make to guarantee that you
have the right name of your terminal device.

<p>
<center>
<table border="2">
<tr>
<td>
<tt><pre>
    #include &lt;stdio.h&gt;

    char *ctermid(char *<i>ptr</i>);                        </pre></tt>
    <p align="right">returns some stuff</p>
</td>
</tr>
</table>
</center>

<p>
If <tt><i>ptr</i></tt> is not null, it must be an array of char's that is
as large as or larger than the macro <tt>L_ctermid</tt> and the name of the
controlling terminal is stored in this array.  If <tt><i>ptr</i></tt> is
null, then the name of the controlling terminal is stored in a static
array.  In both cases, a pointer to the first element of the array storing
the name of the controlling terminal is returned.<p>

Two really cool and usful functions are <tt>isatty()</tt> and
<tt>ttyname()</tt>.

<p>
<center>
<table border="2">
<tr>
<td>
<tt><pre>
    #include &lt;unistd.h&gt;

    int isatty(int <i>filedes</i>);                         </pre></tt>
    <p align="right">Returns: 1 if terminal device, 0 otherwise</p>
    <pre><tt>
    char *ttyname(int <i>filedes</i>);                      </pre></tt>
    <p align="right">Returns: pointer to pathname of terminal, <tt>NULL</tt>
                   on error</p>
</td>
</tr>
</table>
</center>

<p>
These functions are useful in finding out if <tt><i>filedes</i></tt> is
associated with a terminal device or not.  Under the hood, the function
<tt>ttyname()</tt>, searches through the terminal device files in
<tt>/dev/</tt> looking for a matching special file with the same device
number and i-node number as <tt><i>filedes</i></tt>.  If this statement
made no since to you, just ignore it for now. :)

<p><br>
<h2>Captain Cooked Mode! Arrrr! (Wait, was he a pirate?)</h2><p>

So, what is this cooked terminal mode anyway?  When you <tt>read</tt> from
the terminal, if the terminal returns a line at a time instead of each
character as it is received, then you are in cooked (canonical) mode.
There are a number of reasons that can make the <tt>read</tt> return:

<ul>
<li>The requested number of bytes has been read (you hit the end of your
    buffer man!).  The next time you do a <tt>read</tt>, you pick up where
    you left off if you hadn't finished reading the complete line.

<li>It returns when you reach the end of a line which can be any of the
    following characters: <tt>NL</tt>, <tt>EOL</tt>, <tt>EOL2</tt>,
    <tt>EOF</tt>, and <tt>CR</tt> if the <tt>ICRNL</tt> flag is set for the
    terminal and the <tt>IGNCR</tt> flag is not set.  If <tt>EOF</tt> is
    the line delimiter, then it is thrown out.  The others are returned to
    the caller.

<li>If a signal is caught and <tt>SA_RESTART</tt> was not specified as a
    flag to <tt>sigaction()</tt> the <tt>read</tt> will return.
</ul>

<p>
Cooked mode is the default state of your terminal for almost all shells.
At least when you execute another program with the shell, the terminal is
put into cooked mode before it makes a call to an <tt>exec</tt> function.

<p><br>
<h2>Raw!</h2><p>

Raw, or noncanonical for those that don't like raw, is a bit harder to
explain.  It doesn't necessarily return one byte at a time.  You can also
set a time limit for your <tt>read</tt> to return if the number of
characters you want to get have not been received from the device.  The
first step in going into raw mode, no matter what form you want, is to turn
off the flag <tt>ICANON</tt> for your terminal device.  This makes it so
the input is not put into lines before it is returned.  It also makes so
some of the special characters are not processed: <tt>ERASE</tt>,
<tt>KILL</tt>, <tt>EOF</tt>, <tt>NL</tt>, <tt>EOL</tt>, <tt>EOL2</tt>,
<tt>CR</tt>, <tt>REPRINT</tt>, <tt>STATUS</tt>, and <tt>WERASE</tt>.

<p>
So, how do we specify how long to wait for input and how many bytes to read
before we return?  There are two variables in the <tt>c_cc</tt> array in
the termios structure that must be set: <tt>MIN</tt> and <tt>TIME</tt>.
These elements are indexed by the macro defines <tt>VMIN</tt> and
<tt>VTIME</tt>.  <tt>MIN</tt> is the minimum number of bytes that are read
in before returning (<tt>read</tt> blocks until MIN number of bytes have
been read).  <tt>TIME</tt> is the amount of time in tenths of a second to
wait for data to arrive.  So, here is the breakdown of the different cases:

<p>
<dl>
<dt><b>1.&nbsp;&nbsp;&nbsp;&nbsp;</b><tt>MIN &gt; 0</tt> and <tt>TIME &gt; 0</tt></dt>
<dd>In this case, <tt>read</tt> will return if <tt>MIN</tt> number of bytes
    have been read from the device.  It will also return if the number of
    tenths-of-a-second specified in the <tt>TIME</tt> variable have elapsed
    after the first byte has been read.  This means, if nothing is inputed,
    the <tt>read</tt> blocks indefinately.  The timer only starts if a byte
    gets read and does not restart after more bytes are read.</dd>

<p>
<dt><b>2.&nbsp;&nbsp;&nbsp;&nbsp;</b><tt>MIN &gt; 0</tt> and <tt>TIME ==
       0</tt></dt>
<dd>In this case, there is no time limit imposed on the <tt>read</tt>.  It
    will read until at least <tt>MIN</tt> bytes have been received.  This
    can cause <tt>read</tt> to block forever if <tt>MIN</tt> bytes are
    never received.</dd>

<p>
<dt><b>3.&nbsp;&nbsp;&nbsp;&nbsp;</b><tt>MIN == 0</tt> and <tt>TIME &gt;
       0</tt></dt>
<dd>The timer is started as soon as <tt>read</tt> is called.  <tt>read</tt>
    returns only after <tt>TIME</tt> tenths-of-a-second have elapsed or a
    single byte has been received.</dd>

<p>
<dt><b>4.&nbsp;&nbsp;&nbsp;&nbsp;</b><tt>MIN == 0</tt> and <tt>TIME ==
       0</tt></dt>
<dd>In this case, if data is available, the number of bytes requested (or
    all the data if it is less than the number of bytes requested) are
    returned.  If no data is available, <tt>read</tt> returns 0
    immediately.</dd>
</dl>

<p>
This can be a little confusing at first, just read it a couple of times if
you don't understand.  Then let it mull over in your brain.  Try writing a
toy program for each case discussed above.  Here is an example of the use
of the <tt>c_cc</tt> variable:

<p>
<pre><tt>
struct termios trm;

tcgetattr(STDIN_FILENO, &trm;); /* get the current settings */
trm.c_cc[VMIN] = 1;     /* return after one byte read */
trm.c_cc[VTIME] = 0;    /* block forever until 1 byte is read */
        .
        .               /* set some other stuff */
        .
tcsetattr(STDIN_FILENO, TCSANOW, &trm;); /* set the terminal with the new
                                           settings */
</tt></pre>


<p>
<b>Some source code for raw mode taken from the Stevens book:</b><br>
<tt><pre>
#include <termios.h>

static struct termios   save_termios;
static int              term_saved;

int tty_raw(int fd) {       /* RAW! mode */
    struct termios  buf;

    if (tcgetattr(fd, &save;_termios) &lt; 0) /* get the original state */
        return -1;

    buf = save_termios;

    buf.c_lflag &amp;= ~(ECHO | ICANON | IEXTEN | ISIG);
                    /* echo off, canonical mode off, extended input
                       processing off, signal chars off */

    buf.c_iflag &amp;= ~(BRKINT | ICRNL | ISTRIP | IXON);
                    /* no SIGINT on BREAK, CR-toNL off, input parity
                       check off, don't strip the 8th bit on input,
                       ouput flow control off */

    buf.c_cflag &amp;= ~(CSIZE | PARENB);
                    /* clear size bits, parity checking off */

    buf.c_cflag |= CS8;
                    /* set 8 bits/char */

    buf.c_oflag &amp;= ~(OPOST);
                    /* output processing off */

    buf.c_cc[VMIN] = 1;  /* 1 byte at a time */
    buf.c_cc[VTIME] = 0; /* no timer on input */

    if (tcsetattr(fd, TCSAFLUSH, &buf;) &lt; 0)
        return -1;

    term_saved = 1;

    return 0;
}


int tty_reset(int fd) { /* set it to normal! */
    if (term_saved)
        if (tcsetattr(fd, TCSAFLUSH, &save;_termios) &lt; 0)
            return -1;

    return 0;
}
</tt></pre>

<p>
<h2>Window Size</h2><p>
Ever wonder how some terminal applications redraw the screen when you
changed the size of your xterm?  There is a structure that the kernel
maintains for every terminal and pseudo terminal.  This is the
<tt>winsize</tt> struct:

<pre><tt>
    struct winsize {
        unsigned short  ws_row;     /* rows in characters */
        unsigned short  ws_col;     /* columns in characters */
        unsigned short  ws_xpixel;  /* horizontal size in pixels (not used) */
        unsigned short  ws_ypixel;  /* vertical size in pixels (not used) */
    }
</tt></pre>

<p>
The signal <tt>SIGWINCH</tt> is sent to the forground process any time
there is a change made to this strucure in the kernel.  We can get the
current value of this structure by making a call to <tt>ioctl</tt> with
<tt>TIOCGWINSZ</tt> request:

<pre><tt>
    struct winsize  size;

    ioctl(STDIN_FILENO, TIOCGWINSZ, (char *) &size;);
</tt></pre>

To change the structure in kernel memory, a call to <tt>ioctl</tt> is made
with the <tt>TIOCSWINSZ</tt> request:

<pre><tt>
    struct winsize  size;

    ioctl(STDIN_FILENO, TIOCSWINSZ, (char *) &size;);
</tt></pre>

<p>
When you set the size of the structure in the kernel, if the size is
different than it was previously, <tt>SIGWINCH</tt> is sent to the
foreground process.

</body>
</html>
<!--
     FILE ARCHIVED ON 02:09:48 Dec 24, 2016 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 06:13:21 Jan 25, 2022.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  captures_list: 558.691
  exclusion.robots: 0.189
  exclusion.robots.policy: 0.182
  RedisCDXSource: 0.543
  esindex: 0.007
  LoadShardBlock: 538.309 (3)
  PetaboxLoader3.datanode: 436.52 (4)
  CDXLines.iter: 16.316 (3)
  load_resource: 78.768
  PetaboxLoader3.resolve: 33.341
-->